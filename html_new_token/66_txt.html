<p id=p0>In this article, we will solve a <span class='token pointer' id='tok-66-0' style='color:red'>Flag</span><span class='token pointer' id='tok-66-1' style='color:red'>(CTF)</span><span class='token pointer' id='tok-66-2' style='color:red'>Capture the</span>which was posted on <span class='token pointer' id='tok-66-3' style='color:red'>VulnHub</span>by "0katz." </p><p id=p19>As you know from the previous articles in this series, VulnHub is a platform which provides <span class='token pointer' id='tok-66-4' style='color:red'>vulnerable</span>applications/machines to gain practical hands-on experience in the field of information security. You can check my previous articles for more CTF challenges. I have also provided a downloadable <span class='token pointer' id='tok-66-5' style='color:red'>URL</span>for this CTF here, so you can download the machine and run it on <span class='token pointer' id='tok-66-6' style='color:red'>VirtualBox.</span></p><p id=p80>The <span class='token pointer' id='tok-66-7' style='color:red'>torrent</span>downloadable URL is also available for this <span class='token pointer' id='tok-66-8' style='color:red'>VM,</span>which have been added in the reference section of this article. </p><p id=p101>Please Note: For all of these machines, I used <span class='token pointer' id='tok-66-9' style='color:red'>Virtual</span><span class='token pointer' id='tok-66-10' style='color:red'>Oracle</span>to run the downloaded machine. I will be using <span class='token pointer' id='tok-66-11' style='color:red'>Linux</span><span class='token pointer' id='tok-66-12' style='color:red'>Kali</span>an <span class='token pointer' id='tok-66-13' style='color:red'>attacker machine</span>solving this CTF. The techniques used are solely for educational purposes, and I am not responsible if the listed <span class='token pointer' id='tok-66-14' style='color:red'>techniques</span>are used against any other targets. </p><p id=p155>In this walkthrough, we don't need to run the <span class='token pointer' id='tok-66-15' style='color:red'>Netdiscover</span><span class='token pointer' id='tok-66-16' style='color:red'>command</span>to identify the <span class='token pointer' id='tok-66-17' style='color:red'>IP</span><span class='token pointer' id='tok-66-18' style='color:red'>target machine</span>This is because when we run the downloaded virtual machine in the Oracle Virtual Box, it automatically assigns the IP address form <span class='token pointer' id='tok-66-19' style='color:red'>DHCP</span>and shows it on the <span class='token pointer' id='tok-66-20' style='color:red'>terminal.</span>This can be seen in the following <span class='token pointer' id='tok-66-21' style='color:red'>screenshot.</span></p><p id=p210>Temple of Doom Walkthrough, Part 1 </p><p id=p216>So we have found the target machine IP address, which is <span class='token pointer' id='tok-66-22' style='color:red'>192.168.1.9.</span>We will be using <span class='token pointer' id='tok-66-23' style='color:red'>192.168.1.45</span>as an attacker machine in which we have installed Kali Linux. </p><p id=p244>Note: These IP addresses may be different as per your network configuration, as these are assigned by the DHCP. </p><p id=p263>Let's move to the next step which is <span class='token pointer' id='tok-66-24' style='color:red'>port scanning.</span>am using <span class='token pointer' id='tok-66-25' style='color:red'>Nmap,</span>which is the best tool for port scanning. The completed output of the Nmap result can be seen in the following screenshot. </p><p id=p299><span class='token pointer' id='tok-66-26' style='color:red'>nmap</span><span class='token pointer' id='tok-66-27' style='color:red'>Command Used:</span>-Pn 192.168.1.9 </p><p id=p305>Explanation: </p><p id=p306>-p- option is used for complete <span class='token pointer' id='tok-66-28' style='color:red'>port scan-Pn</span>is used for <span class='token pointer' id='tok-66-29' style='color:red'>no-ping</span>scan-sV option is used for service detectionAs observed in above screenshot, two ports were identified as open. And as we already know from our previous <span class='token pointer' id='tok-66-30' style='color:red'>CTF-solving</span>experience that we can't find any interesting information service with the <span class='token pointer' id='tok-66-31' style='color:red'>SSH port,</span>decided to start with the HTTP port. Here, the HTTP service is running on <span class='token pointer' id='tok-66-32' style='color:red'>Port 666.</span>open it into the browser. </p><p id=p381>As can be seen in the above screenshot, it shows an under-construction page. Now, for exploring further, it's time to run the <span class='token pointer' id='tok-66-33' style='color:red'>dirb</span>tool to identify other entry points on the target machine. The output of dirb can be seen in the screenshot given below. </p><p id=p426>Command Used: </p><p id=p428>dirb <span class='token pointer' id='tok-66-34' style='color:red'>http://192.168.1.9:666/</span></p><p id=p430>As we can see in the above screenshot, dirb does not give any result which could be further explored. This is very strange, because we always get something with the dirb tool. </p><p id=p462>Now, we have another tool to search for weakness in the <span class='token pointer' id='tok-66-35' style='color:red'>target system.</span>is <span class='token pointer' id='tok-66-36' style='color:red'>Nikto Scan.</span>run this scan and see what we get. </p><p id=p488></p><p id=p490>nikto –host http://192.168.1.9:666/ </p><p id=p493>We did not find anything useful from the Nikto scan also. This is a little <span class='token pointer' id='tok-66-37' style='color:red'>suspicious.</span></p><p id=p509>As all the exploration techniques we have tried are not providing any useful data, let's check the under-construction web page on the target machine for any hidden clues. While checking this page with the <span class='token pointer' id='tok-66-38' style='color:red'>Burp Suite proxy,</span>was observed that a session cookie is being sent in the <span class='token pointer' id='tok-66-39' style='color:red'>response</span>from the server end. It can be seen in the below screenshot. </p><p id=p571>You can see a session cookie in the server response in the <span class='token pointer' id='tok-66-40' style='color:red'>highlighted</span>area. </p><p id=p585>When I closely look at it, its looks like an URL encoding string, as it has the '%3d' characters at the end of the string. I used <span class='token pointer' id='tok-66-41' style='color:red'>Burp Decoder</span>decode the cookie value. After the URL decoding of the string, we need to decode it one more time with <span class='token pointer' id='tok-66-42' style='color:red'>base64 decoding</span>view the actual data in the cookie. It can be seen in the following screenshot. </p><p id=p653>After decoding the session cookie, we have identified that the username <span class='token pointer' id='tok-66-43' style='color:red'>csrftoken</span>and expires parameter is being passed in the session cookie. So, I created another <span class='token pointer' id='tok-66-44' style='color:red'>GET</span>request with the above session cookie and sent it to the server through <span class='token pointer' id='tok-66-45' style='color:red'>Burp Repeater.</span>returned a 500 error code with some informational error messages that can be seen in the screenshot given below. </p><p id=p715>From the error messages in the above screenshot, we get some clue that <span class='token pointer' id='tok-66-46' style='color:red'>Nodeadmin</span>and Node-Serialize are being used on the target application. </p><p id=p738>After playing with the session cookie, I identified that <span class='token pointer' id='tok-66-47' style='color:red'>CSRF</span>token and the "expire" parameter in the session cookie are not playing any role in the session. So, I used the simple username "admin" and encode it into <span class='token pointer' id='tok-66-48' style='color:red'>base64</span>by using Burp Decoder and pass it in the cookie on the repeater. We received the output "Hello Admin" from the server. </p><p id=p799>We already know from the error message that <span class='token pointer' id='tok-66-49' style='color:red'>"Node-Serialize"</span>is being used in the target application. So I searched for "Node-Serialize" <span class='token pointer' id='tok-66-50' style='color:red'>vulnerabilities</span>on Google, and the very first result shows that it is vulnerable to <span class='token pointer' id='tok-66-51' style='color:red'>(RCE).</span><span class='token pointer' id='tok-66-52' style='color:red'>Remote Code Execution</span>can be seen in the below screenshot. </p><p id=p846></p><p id=p850>We have found <span class='token pointer' id='tok-66-53' style='color:red'>vulnerability.</span><span class='token pointer' id='tok-66-54' style='color:red'>Remote Code Execution (RCE)</span>us see if we could use this exploit in our scenario to get the access of our target machine. After getting the information about the vulnerability and the exploit from google, I was able to create a payload which could be used to exploit the vulnerability. </p><p id=p906><span class='token pointer' id='tok-66-55' style='color:red'>Payload:</span></p><p id=p907><span class='token pointer' id='tok-66-56' style='color:red'>require('child_process').execSync('ls</span><span class='token pointer' id='tok-66-57' style='color:red'>{"username":"_$$ND_FUNC$$_function(){return</span><span class='token pointer' id='tok-66-58' style='color:red'>/',(e,out,err)=>{console.log(out);});</span>}()"} </p><p id=p912>In the highlighted area we can see the command which we wanted to execute on the target machine. As the application is using a <span class='token pointer' id='tok-66-59' style='color:red'>base64-encoded</span>cookie, we need to convert our payload into <span class='token pointer' id='tok-66-60' style='color:red'>base64 encoding.</span>can be easily done with the <span class='token pointer' id='tok-66-61' style='color:red'>Burp Suite Decoder.</span>can also be seen in the <span class='token pointer' id='tok-66-62' style='color:red'>following</span>screenshot. </p><p id=p966><span class='token pointer' id='tok-66-63' style='color:red'>encoded</span><span class='token pointer' id='tok-66-64' style='color:red'>Final Base 64</span>is given below. </p><p id=p975><span class='token pointer' id='tok-66-65' style='color:red'>eyJ1c2VybmFtZSI6Il8kJE5EX0ZVTkMkJF9mdW5jdGlvbigpe3JldHVybiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMoJ2xzIC1sIC8nLChlLG91dCxlcnIpPT57Y29uc29sZS5sb2cob3V0KTt9KTsgfSgpIn0=</span></p><p id=p976>Now let's add this payload in the cookie and hit it by using the <span class='token pointer' id='tok-66-66' style='color:red'>Burp Suite Repeater.</span>server response can be seen in the following screenshot. </p><p id=p1003>Through the above payload, we are successfully able to execute the command on the target system. So now let's take the <span class='token pointer' id='tok-66-67' style='color:red'>shell</span><span class='token pointer' id='tok-66-68' style='color:red'>reverse</span>the target machine. We would be using the <span class='token pointer' id='tok-66-69' style='color:red'>Netcat</span>utility to take the reverse shell. </p><p id=p1042>At first, let's verify whether the target machine has the Netcat installed. We can verify this by running the <span class='token pointer' id='tok-66-70' style='color:red'>nc –help</span>If the Netcat utility is available on the target machine, it would give the help command output; otherwise, a blank page would be returned from the server. </p><p id=p1091>As can be seen in the above screenshot, we got the help command details in the server response. It confirms that Netcat can be used for taking the reverse shell. So let's create a payload to take the reverse shell of the target system.
 </p>