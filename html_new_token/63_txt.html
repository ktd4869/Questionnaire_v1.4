<p id=p0>In this article, we will be solving all <span class='token pointer' id='tok-63-0' style='color:red'>networking</span>challenges and one <span class='token pointer' id='tok-63-1' style='color:red'>remote buffer overflow challenge</span><span class='token pointer' id='tok-63-2' style='color:red'>Protostar.</span></p><p id=p18>IntroductionThese levels introduce us to the fundamental concept of sending and receiving data over a <span class='token pointer' id='tok-63-3' style='color:red'>network</span>in a different format, and the hurdles of <span class='token pointer' id='tok-63-4' style='color:red'>debugging</span>and developing an <span class='token pointer' id='tok-63-5' style='color:red'>stack</span><span class='token pointer' id='tok-63-6' style='color:red'>remote</span>We will have a look at how we can <span class='token pointer' id='tok-63-7' style='color:red'>debug</span>and understand what inputs the <span class='token pointer' id='tok-63-8' style='color:red'>program</span>expects from us. </p><p id=p70>The following <span class='token pointer' id='tok-63-9' style='color:red'>code</span><span class='token pointer' id='tok-63-10' style='color:red'>assembly</span>obtained after disassembling the <span class='token pointer' id='tok-63-11' style='color:red'>Net0</span><span class='token pointer' id='tok-63-12' style='color:red'>binary.</span>As we can see, the application executes <span class='token pointer' id='tok-63-13' style='color:red'>run function</span>the main function. The run function generates a random number and uses <span class='token pointer' id='tok-63-14' style='color:red'>call to print</span>on the screen. It further checks whether our input matches to the random() number generated by comparing our <span class='token pointer' id='tok-63-15' style='color:red'>raw input</span>random number generated previously. </p><p id=p134>Our logic for solving this challenge will be composed of following steps: </p><p id=p146><span class='token pointer' id='tok-63-16' style='color:red'>serverRecv()</span><span class='token pointer' id='tok-63-17' style='color:red'>Connect to</span><span class='token pointer' id='tok-63-18' style='color:red'>dataParse</span>the data and take out the random number ask by the <span class='token pointer' id='tok-63-19' style='color:red'>applicationPack</span>the random number in <span class='token pointer' id='tok-63-20' style='color:red'>little-endian format</span>send it back.Using the logic listed above, we came up with the following piece of code and successfully passed this challenge. </p><p id=p191><span class='token pointer' id='tok-63-21' style='color:red'>Net 1By</span>at the disassembled code of <span class='token pointer' id='tok-63-22' style='color:red'>Net1,</span><span class='token pointer' id='tok-63-23' style='color:red'>binary</span>can understand following things: </p><p id=p206>The program generates a random number and stores the <span class='token pointer' id='tok-63-24' style='color:red'>integer</span>as a string at <span class='token pointer' id='tok-63-25' style='color:red'>ebp-0x24.It</span>then writes the content of number generated to <span class='token pointer' id='tok-63-26' style='color:red'>stdout.It</span>then takes input from user removes <span class='token pointer' id='tok-63-27' style='color:red'>CRLF characters</span>compare the input with the contents of <span class='token pointer' id='tok-63-28' style='color:red'>ebp-0x24</span>variable saved earlier.As in this case, the <span class='token pointer' id='tok-63-29' style='color:red'>data</span>is already packed in <span class='token pointer' id='tok-63-30' style='color:red'>32-bit integers.</span>will be using similar logic from the <span class='token pointer' id='tok-63-31' style='color:red'>NET0</span>level and after receiving the data we will be unpacking it to 32-bit integer and send the unpacked value back as it is. </p><p id=p293>Finally, we came up with following piece of code that will solve this challenge. </p><p id=p307><span class='token pointer' id='tok-63-32' style='color:red'>Net 2By</span>at the disassembled code of <span class='token pointer' id='tok-63-33' style='color:red'>Net2,</span><span class='token pointer' id='tok-63-34' style='color:red'>binary</span>can understand following things: </p><p id=p322>The application generates four random numbers and sends in four <span class='token pointer' id='tok-63-35' style='color:red'>iterations using</span>(). It also keeps on adding them and stores the overall result at <span class='token pointer' id='tok-63-36' style='color:red'>ebp-0xc.</span>As a result might overflow its limit, it will wrap, so we need to take care of that in our code too. Finally, it checks the input provided by the user matches the added numbers, so we need to pack our input to an unsigned int to take care of that. </p><p id=p400>We came up with the following piece of code to solve this challenge using the following algorithm: </p><p id=p417>Connect to the <span class='token pointer' id='tok-63-37' style='color:red'>server.recv ()</span><span class='token pointer' id='tok-63-38' style='color:red'>bytes</span>of data from the server iteratively four times and add <span class='token pointer' id='tok-63-39' style='color:red'>AND operation</span>the final sum, so the result stays in <span class='token pointer' id='tok-63-40' style='color:red'>32 unsigned int's range.Pack</span>result and send it back to the server. </p><p id=p460>This level takes us back to <span class='token pointer' id='tok-63-41' style='color:red'>stack based buffer overflows</span>little restrictions added here and there. Let's have a look at the disassembled code for this level. By looking at the code we can quickly figure out the vulnerable <span class='token pointer' id='tok-63-42' style='color:red'>function gets()</span>used but the problem is our input gets passed through the for loop which iterates each of our provided bytes thus it will corrupt any <span class='token pointer' id='tok-63-43' style='color:red'>shellcode.</span></p><p id=p532>So, let's start with fuzzing the application and figuring out the <span class='token pointer' id='tok-63-44' style='color:red'>EIP.</span><span class='token pointer' id='tok-63-45' style='color:red'>offset to</span>we use <span class='token pointer' id='tok-63-46' style='color:red'>Python's</span><span class='token pointer' id='tok-63-47' style='color:red'>pwntools library</span>generating a <span class='token pointer' id='tok-63-48' style='color:red'>cyclic pattern</span>end up with following snippet of code. </p><p id=p565>An observant user must have noticed that application is using <span class='token pointer' id='tok-63-49' style='color:red'>forking technique</span>serve connections thus debugging using process id will not work for <span class='token pointer' id='tok-63-50' style='color:red'>runtime analysis.</span>we need to debug <span class='token pointer' id='tok-63-51' style='color:red'>child process.</span>placed a breakpoint after <span class='token pointer' id='tok-63-52' style='color:red'>strdup (0x0804982a)</span>started analyzing the state of the process. </p><p id=p613>As we will need to debug the same process multiple times so it will be a bit painful to set <span class='token pointer' id='tok-63-53' style='color:red'>gdb commands</span>time, therefore we will be using the <span class='token pointer' id='tok-63-54' style='color:red'>.gdbinit</span>file for the sake of <span class='token pointer' id='tok-63-55' style='color:red'>automation.</span></p><p id=p650>After editing the <span class='token pointer' id='tok-63-56' style='color:red'>.gdbinit file and</span>our <span class='token pointer' id='tok-63-57' style='color:red'>fuzz string</span>got an <span class='token pointer' id='tok-63-58' style='color:red'>$eip overwrite</span><span class='token pointer' id='tok-63-59' style='color:red'>0x46414149,</span>our input is placed on the stack and <span class='token pointer' id='tok-63-60' style='color:red'>$eax</span>points to some part of our shellcode mainly from the start because of <span class='token pointer' id='tok-63-61' style='color:red'>strdup() function</span>returns in $eax. We further used <span class='token pointer' id='tok-63-62' style='color:red'>cyclic_find function</span><span class='token pointer' id='tok-63-63' style='color:red'>pwntools</span>to get offset to $eip at 532. </p><p id=p709>Ethical Hacking Training â€“ Resources (InfoSec) </p><p id=p715>Now there are multiple options for writing exploit for this program: </p><p id=p726><span class='token pointer' id='tok-63-64' style='color:red'>Return to register: call eax</span>Alpha upper <span class='token pointer' id='tok-63-65' style='color:red'>shellcode)Jump</span>to stack: At the time of the crash, no pointers to our shellcode were present on the stack we need to rely on the hardcoded address (Not a reliable way). Also, we do not need alphanumeric shellcode in this case as gets will copying our input into <span class='token pointer' id='tok-63-66' style='color:red'>buffer</span>after it meets a null bytes <span class='token pointer' id='tok-63-67' style='color:red'>(\x00).ROP Chain via ret2libc:</span>there is no <span class='token pointer' id='tok-63-68' style='color:red'>ASLR</span>enabled on the system we can rely on the PLT address from the executable itself construct a simple ROP chain. (Reliable unless ASLR is enabled even in that case we need to modify our shellcode to make it work again slightly)Our ROP chain will do the following: </p><p id=p845>Read the contents of system command in .dynamic section.Pass the pointer of .dynamic to execve. </p><p id=p860>As we see in the following screenshot, we were able to obtain remote shell by exploiting final0 binary. </p><p id=p878>    </p>