<p id=p0>The <span class='token pointer' id='tok-62-0' style='color:red'>driver</span>is the first <span class='token pointer' id='tok-62-1' style='color:red'>Duqu</span><span class='token pointer' id='tok-62-2' style='color:red'>component of</span>be loaded in the system. As we discovered, the driver and other components of <span class='token pointer' id='tok-62-3' style='color:red'>malware</span>are installed with a <span class='token pointer' id='tok-62-4' style='color:red'>dropper</span>exploiting a 0-day vulnerability <span class='token pointer' id='tok-62-5' style='color:red'>(CVE-2011-3402).</span>The driver is registered in the <span class='token pointer' id='tok-62-6' style='color:red'>registry path.</span>exact name of the <span class='token pointer' id='tok-62-7' style='color:red'>registry key</span>in different versions of Duqu drivers. </p><p id=p57>Once the driver is loaded, it <span class='token pointer' id='tok-62-8' style='color:red'>decrypts</span>a small block that contains its registry key and the name of the <span class='token pointer' id='tok-62-9' style='color:red'>registry value</span>be read from that key. It also contains the name of the driver object to create. </p><p id=p96>All versions of the driver available at the moment have the same registry value name, "FILTER". </p><p id=p112>The driver then registers the <span class='token pointer' id='tok-62-10' style='color:red'>DriverReinitializationRoutine</span>that queues the <span class='token pointer' id='tok-62-11' style='color:red'>WorkerRoutine</span>where actual <span class='token pointer' id='tok-62-12' style='color:red'>driver initialization</span>performed. In the WorkerRoutine the driver reads the "FILTER" value from registry and decrypts it with a <span class='token pointer' id='tok-62-13' style='color:red'>hard-coded encryption key.</span>are two known versions of <span class='token pointer' id='tok-62-14' style='color:red'>decryption routine</span>two corresponding <span class='token pointer' id='tok-62-15' style='color:red'>decryption keys.</span>driver also locates the <span class='token pointer' id='tok-62-16' style='color:red'>NTOSKRNL.EXE</span>or <span class='token pointer' id='tok-62-17' style='color:red'>module</span><span class='token pointer' id='tok-62-18' style='color:red'>NTKRNLPA.EXE</span>gets the addresses of <span class='token pointer' id='tok-62-19' style='color:red'>API functions</span>further usage. </p><p id=p179>The <span class='token pointer' id='tok-62-20' style='color:red'>decrypted</span>"FILTER" value from registry contains the list of records that contain the name of the process ("services.exe"), the path to corresponding <span class='token pointer' id='tok-62-21' style='color:red'>PNF DLL file</span>will be injected in that process and the decryption key (0xAE240682) that is used to decrypt the PNF DLL file. </p><p id=p226>After initialization the driver registers  <span class='token pointer' id='tok-62-22' style='color:red'>LoadImageNotifyRoutine</span>that will be then called by Windows each time a new module is loaded. The routine checks if the name of image matches one of these specified in "FILTER" value and if it does, starts the injection: it decrypts and copies the PNF DLL file into an <span class='token pointer' id='tok-62-23' style='color:red'>allocate memory region</span>that process. It also builds an copies a <span class='token pointer' id='tok-62-24' style='color:red'>stub EXE file</span>that process that is then used as a <span class='token pointer' id='tok-62-25' style='color:red'>loader</span>for the <span class='token pointer' id='tok-62-26' style='color:red'>PNF</span><span class='token pointer' id='tok-62-27' style='color:red'>DLL.</span></p><p id=p309>As soon as <span class='token pointer' id='tok-62-28' style='color:red'>"KERNEL32.DLL"</span>is loaded in the same process, it locates addresses of API functions required by the loader EXE and modifies the original entry point of the main process module so that it passes execution to the loader </p><p id=p351>The loader <span class='token pointer' id='tok-62-29' style='color:red'>EXE module</span>initial initialization of the <span class='token pointer' id='tok-62-30' style='color:red'>PNF DLL module</span>then executes the export as specified in the configuration ("FILTER"). After that it restores the code of the original entry point and returns execution to the original process module. The loader also interacts with the driver module using a <span class='token pointer' id='tok-62-31' style='color:red'>custom IOCTL code</span>change <span class='token pointer' id='tok-62-32' style='color:red'>memory protection</span>the original entry point code. </p><p id=p416>This module is stored on disk as an <span class='token pointer' id='tok-62-33' style='color:red'>encrypted block of data.</span>soon as it is decrypted, it turns out to be a DLL packed with <span class='token pointer' id='tok-62-34' style='color:red'>UPX.</span> Known versions of PNF DLL modules export 8 or 6 different functions by ordinal numbers. </p><p id=p460><span class='token pointer' id='tok-62-35' style='color:red'>Export 2</span>export 6 in a separate process. </p><p id=p469>Export 4 runs export 5 in a separate process. </p><p id=p478>Export 5 starts a thread in "services.exe" process that loaded the <span class='token pointer' id='tok-62-36' style='color:red'>302 resource</span>below) and, if provided with correct information by the callee, installs a complete new set of Duqu components. </p><p id=p510>Export 6 stops the driver and completely uninstalls all components of Duqu. </p><p id=p522>Export 8 and 1 initialize the PNF DLL module and start main threads. </p><p id=p535>It seems that ordinal 1 <span class='token pointer' id='tok-62-37' style='color:red'>is</span>intended to export primary functionality of the DLL. First, it loads the configuration information from another PNF file, the PNF <span class='token pointer' id='tok-62-38' style='color:red'>Config</span>file. If the file is not present, it is created from an encrypted hard-coded copy that is stored in the PNF DLL file. </p><p id=p585>The name of the configuration file is different for every version of Duqu. The PNF Config contains the name and path to the driver <span class='token pointer' id='tok-62-39' style='color:red'>component,</span>to the PNF DLL and PNF Config itself. </p><p id=p618>When the PNF Config is created, the date of creation is written into the file. The file also contains the <span class='token pointer' id='tok-62-40' style='color:red'>TTL</span>("time to live") value: a separate thread started by PNF DLL monitors if TTL days passed since the creation date, and after that runs the uninstallation routine. </p><p id=p666>Some versions of the PNF DLL also start an <span class='token pointer' id='tok-62-41' style='color:red'>RPC server</span>to the one found in <span class='token pointer' id='tok-62-42' style='color:red'>Stuxnet.</span></p><p id=p684>The PNF DLL also provides <span class='token pointer' id='tok-62-43' style='color:red'>API</span>for manipulating the configuration file from <span class='token pointer' id='tok-62-44' style='color:red'>external modules</span></p><p id=p702>Depending on the flags in the PNF Config, the PNF DLL code looks for specific processes: the list of process names in the PNF Config, "explorer.exe", "svchost.exe" and then injects code in them. The code to be injected is stored in <span class='token pointer' id='tok-62-45' style='color:red'>binary resource 302</span>in PNF DLL. </p><p id=p750>Depending on the flag in the PNF configuration file, it is either a DLL loader module or a block of data (equivalent of <span class='token pointer' id='tok-62-46' style='color:red'>decompressed ".zdata",</span>below). Both configuration have been found in different Duqu versions. The PNF DLL checks a flag in PNF Config and determines whether to pass execution to the DLL loader or to locate the <span class='token pointer' id='tok-62-47' style='color:red'>payload</span>DLL and call it directly. </p><p id=p815>The loader DLL module is similar to PNF DLL. The main purpose of the loader is to decompress its ".zdata" section and pass execution to the main payload that is contained in decompressed data. </p><p id=p849>The <span class='token pointer' id='tok-62-48' style='color:red'>.zdata block</span>the header that starts with the magic number 0x48747193. It contains the offsets and sizes of the DLL loader, the payload configuration block and the payload DLL. </p><p id=p880></p><p id=p882>The configuration block contains the name of the temporary file to use %TEMP%~DR0001.tmp, additional binary data controlling the behavior of the payload and information required to connect to the <span class='token pointer' id='tok-62-49' style='color:red'>C&C servers.</span>are two lists of <span class='token pointer' id='tok-62-50' style='color:red'>C&C</span>servers, one can contain domain names, <span class='token pointer' id='tok-62-51' style='color:red'>IP addresses</span>names of <span class='token pointer' id='tok-62-52' style='color:red'>network shares,</span>the other contains IP addresses in binary format and is used to connect using Windows <span class='token pointer' id='tok-62-53' style='color:red'>HTTP</span><span class='token pointer' id='tok-62-54' style='color:red'>(winhttp)</span>services. Although the configuration blocks we have found so far are similar and are set up to connect to its C&C using HTTP and HTTPS, the payload DLL is able to connect to a network share and even become a server. </p><p id=p991>We are still analyzing the payload. It contains 256K of <span class='token pointer' id='tok-62-55' style='color:red'>C++ code</span>extensive use of <span class='token pointer' id='tok-62-56' style='color:red'>STL</span>and its own complex class hierarchies, probably own framework. </p><p id=p1017>The payload is able to connect to C&C server using either winhttp library or connection to a network share <span class='token pointer' id='tok-62-57' style='color:red'>IPC$ endpoint.</span>is able to connect using proxy server configuration of Internet Explorer. It also contains code for acting as a HTTP server and processing the same requests as served by the C&C. </p><p id=p1070>The payload is able to load an external DLL module provided by the C&C and interact with it using a pre-defined API. The most noticeable module discovered so far is the <span class='token pointer' id='tok-62-58' style='color:red'>infostealer module.</span>are also modules for updating the TTL value in the PNF DLL configuration, for reading the network and disk storage configuration from the infected machine. </p><p id=p1129>It also can form a PNF DLL with a configuration block and the payload DLL ready for distribution to other machines.
 </p>