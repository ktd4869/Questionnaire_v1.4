<p id=p0>For this lab we'll be using <span class='token pointer' id='tok-67-0' style='color:red'>GPG,</span><span class='token pointer' id='tok-67-1' style='color:red'>OpenSSL</span>to demonstrate <span class='token pointer' id='tok-67-2' style='color:red'>symmetric and asymmetric encryption/decryption</span><span class='token pointer' id='tok-67-3' style='color:red'>MD5,</span><span class='token pointer' id='tok-67-4' style='color:red'>SHA1</span>to demonstrate <span class='token pointer' id='tok-67-5' style='color:red'>hash</span>functions. </p><p id=p21>Virtual Machine Needed: <span class='token pointer' id='tok-67-6' style='color:red'>Kali</span></p><p id=p25>Before starting the lab here are some definitions: </p><p id=p33>In all <span class='token pointer' id='tok-67-7' style='color:red'>symmetric crypto algorithms</span>called Secret Key encryption) a secret key is used for both <span class='token pointer' id='tok-67-8' style='color:red'>encrypt</span><span class='token pointer' id='tok-67-9' style='color:red'>plaintext</span>and <span class='token pointer' id='tok-67-10' style='color:red'>decrypt</span>the <span class='token pointer' id='tok-67-11' style='color:red'>ciphertext.</span>The secret key can be a number, a word, or a string of random letter, once applied to a given data (message, text). </p><p id=p79>We can distinguish two kinds of symmetric cryptographic <span class='token pointer' id='tok-67-12' style='color:red'>algorithms:</span>Classic and Modern. </p><p id=p91>Some of the classic algorithms are: <span class='token pointer' id='tok-67-13' style='color:red'>Cesare,</span><span class='token pointer' id='tok-67-14' style='color:red'>Vigenere,</span>and <span class='token pointer' id='tok-67-15' style='color:red'>XORSome</span>of the modern algorithms are: <span class='token pointer' id='tok-67-16' style='color:red'>RC4,</span><span class='token pointer' id='tok-67-17' style='color:red'>Data Encryption Standard (DES) and</span>Encryption Standard <span class='token pointer' id='tok-67-18' style='color:red'>(AES),</span><span class='token pointer' id='tok-67-19' style='color:red'>CAST5The</span>process can be <span class='token pointer' id='tok-67-20' style='color:red'>schematized</span>(whatever the algorithm used is) as follow: </p><p id=p128>When it comes to asymmetric crypto algorithms, two keys are used — one called <span class='token pointer' id='tok-67-21' style='color:red'>public key,</span>the other is called <span class='token pointer' id='tok-67-22' style='color:red'>private key.</span>the public key can encrypt is only decrypted using the private key. In general, a message is encrypted with a public key and only person with the private key can decrypt it. </p><p id=p184>The high-level process is as follow: </p><p id=p190>The difference between encryption either symmetric or asymmetric and hashing is the fact that hash functions are not reversible, no private key, <span class='token pointer' id='tok-67-23' style='color:red'>passphrase</span>or password is used, and almost all hashing function produce a fixed length output from a given arbitrary length input. The main point of difference is the <span class='token pointer' id='tok-67-24' style='color:red'>one-way mapping</span>the input and the output. It's theoretically impossible to get a plaintext from a hashed value. The two most commonly used hash algorithms are MD5 and SHA1 with the respectively fixed length output of 32 characters and 40 characters. </p><p id=p282>Due to its "predictive" nature and to avoid dictionary attacks against hashed passwords or passphrases by using pre-calculated hashes for every value, a salt is random data that is used as an additional input to a one-way function that "hashes" a password or passphrase. In a typical circumstance, a password is concatenated with a salt value before hashing them. The salt in the schemas below is 3ab9 </p><p id=p349>And by contrast to all of this, encoding is not a cryptographic concept; it's simply putting a sequence of characters into a given format for transmission or storage purpose. UTF, ASCII, UNICODE, and Base64 are examples of encoding systems. </p><p id=p388><span class='token pointer' id='tok-67-25' style='color:red'>Encryption/DecryptionUsing GPGEncryption</span><span class='token pointer' id='tok-67-26' style='color:red'>Symmetric KeyCreate</span>file on your <span class='token pointer' id='tok-67-27' style='color:red'>desktop folder</span>the <span class='token pointer' id='tok-67-28' style='color:red'>command:</span></p><p id=p402><span class='token pointer' id='tok-67-29' style='color:red'>/root/Desktop/sample.txt</span></p><p id=p406>This is a sample text. </p><p id=p411>And use Ctrl+D to save an exit: </p><p id=p418>Execute the following command to encrypt the file sample.txt using a symmetric key. The first time when GPG is run, a <span class='token pointer' id='tok-67-30' style='color:red'>.gnupg</span>folder is created. You will be asked to enter a passphrase twice. The passphrase used is "infosec": </p><p id=p457>root@attackserver:~# gpg -c /root/Desktop/sample.txt </p><p id=p461>The option "-c" indicated the GPG to use symmetric keys. </p><p id=p471>An encrypted file is now created in the same location as the plaintext file with the name sample.txt.gpg to see difference in file, open the plain text using the command cat /root/Desktop/sample.txt then open the encrypted file using the command cat /root/Desktop/sample.txt.gpg: </p><p id=p513>The encrypted file is unreadable, and GPG 2.0 uses by default CAST5 encryption. </p><p id=p526>Decryption using Symmetric KeyTo decrypt the previously encrypted file run the following command: </p><p id=p539></p><p id=p543>You will be prompted to enter the passphrase used to encrypt. Once you enter that correctly, "sample_decrypted.txt" file will be created on your Desktop folder: </p><p id=p568>Use the command cat /root/Desktop/sample_decrypted.txt to view its content: </p><p id=p577>Using <span class='token pointer' id='tok-67-31' style='color:red'>OpenSSLAsymmetric</span>encryptionAs explained in the introduction, we need first to generate a <span class='token pointer' id='tok-67-32' style='color:red'>public/private key</span>to use asymmetric encryption. For this purpose, we will use RSA with OpenSSL to generate a private key (infosec_private_key.pem) with the size 1024 bytes. To generate a private key execute this command: </p><p id=p625></p><p id=p630>The private key is now stored as infosec_private_key.pem on the desktop folder. Next step is to derivate the public key from our generated private key using the following command: </p><p id=p659></p><p id=p668>At this point now on the Desktop folder, we have both public and </p><p id=p683>To encrypt the previously created sample.txt file, from the terminal window execute the following command: </p><p id=p698>openssl rsautl -encrypt -inkey /root/Desktop/infosec _public_key.pem -pubin -in /root/Desktop/sample.txt -out /root/Desktop/asymmetric_encrypt.dat </p><p id=p709>Try to open the asymmetric_encrypt.dat file using cat command: </p><p id=p718>Asymmetric decryptionAs seen, asymmetric_encrypt.dat is unreadable and must be decrypted only using the private key we previously generated. </p><p id=p736>To decrypt the file, from the terminal window execute the following command: </p><p id=p748>openssl rsautl -decrypt -inkey /root/Desktop/infosec_private_key.pem -in /root/Desktop/asymmetric_encrypt.dat -out /root/Desktop/asymmetric_decrypt.txt </p><p id=p757>Now try to view the file using cat command: </p><p id=p766>HashingTo get an MD5 hash of a plaintext phrase using your terminal, execute the following command: echo -n "This is a sample text" | md5sum </p><p id=p791>The value 6029f28561014cd2fccef51253be6dbb (which is 32 characters long) is the MD5 hash equivalent of "This is a sample text" if you input a longer phrase as "This is a sample text, crypto is awesome." </p><p id=p825>The output is obviously different, but it remains 32 characters long. </p><p id=p836>You can try to hash the same phrases using SHA1 algorithm by running the command: echo -n "This is a sample text" | sha1sum </p><p id=p860>Md5sum and sha1sum can be used to verify file integrity, so to have the md5 and sha1 hash values of the previously sample.txt file we can execute the commands: </p><p id=p889>echo –n /root/Desktop/sample.txt | md5sum </p><p id=p894>echo –n /root/Desktop/sample.txt | sha1sum </p><p id=p899>Even changing a single letter or switching from upper to lower case a single character will produce a different hash. As you can see from SHA2: </p><p id=p925>echo -n "This is a sample text" | sha256sum </p><p id=p934>Ethical Hacking Training – Resources (InfoSec) </p><p id=p940>Now for generating a salted SHA2 hash using the password 'infosec' and the salt 'infosecSalt" we can use the command bellow: </p><p id=p961>mkpasswd -m sha-256 -S infosecSalt -s <<< infosec </p><p id=p969>You can type the command mkpasswd -m help to see supported hash functions: </p><p id=p982>EncodingBase64 is one of the most used binary-to-text encoding system that represents binary data in an ASCII string format by translating it into a radix-64 (https://en.wikipedia.org/wiki/Radix) representation. </p><p id=p1009>The sample "This is a sample text" is represented as a byte sequence of 8-bit-padded ASCII characters encoded in MIME's Base64 scheme (https://en.wikipedia.org/wiki/MIME) as follows: </p><p id=p1034>"VGhpcyBpcyBhIHNhbXBsZSB0ZXh0" </p><p id=p1035>The command used is: </p><p id=p1039>echo -n This is a sample text | base64 </p><p id=p1048>To decode a base64 byte sequence, use the following command: </p><p id=p1058>echo -n VGhpcyBpcyBhIHNhbXBsZSB0ZXh0| base64 –d </p><p id=p1063>    </p>