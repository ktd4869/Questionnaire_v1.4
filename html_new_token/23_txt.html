<p id=p0>Introduction </p><p id=p1>In 1968 and 1969, the <span class='token pointer' id='tok-23-0' style='color:red'>smartcard</span>was <span class='token pointer' id='tok-23-1' style='color:red'>patented</span>in German by Helmut Gröttrup and <span class='token pointer' id='tok-23-2' style='color:red'>Jürgen</span>Dethloff. The smartcard is simply a card with an <span class='token pointer' id='tok-23-3' style='color:red'>Integrated</span><span class='token pointer' id='tok-23-4' style='color:red'>Circuit</span>that could be programmed. This <span class='token pointer' id='tok-23-5' style='color:red'>technology</span>has been used widely in our daily lives and will become one of the important keys in <span class='token pointer' id='tok-23-6' style='color:red'>Internet of Things (IoT)</span><span class='token pointer' id='tok-23-7' style='color:red'>(M2M)</span><span class='token pointer' id='tok-23-8' style='color:red'>Machine to Machine</span><span class='token pointer' id='tok-23-9' style='color:red'>Smartcard</span>applications could be <span class='token pointer' id='tok-23-10' style='color:red'>Java</span><span class='token pointer' id='tok-23-11' style='color:red'>Card,</span><span class='token pointer' id='tok-23-12' style='color:red'>programmed using</span>open platform from Sun <span class='token pointer' id='tok-23-13' style='color:red'>Microsystems.</span>Today, we find smartcard technology mostly used in communications <span class='token pointer' id='tok-23-14' style='color:red'>(GSM/CDMA Sim Card)</span>payments (credit/debit card). This is an example of smartcard technology that has been used in Indonesia: </p><p id=p103>Computer Forensics Training – Resources (InfoSec) </p><p id=p109>How Does the Smartcard Work? </p><p id=p114>1. </p><p id=p117>In order to interact with the smartcard that has been connected to a smartcard <span class='token pointer' id='tok-23-15' style='color:red'>terminal,</span>it should be activated using electrical <span class='token pointer' id='tok-23-16' style='color:red'>signals</span><span class='token pointer' id='tok-23-17' style='color:red'>according</span>to smartcard specification <span class='token pointer' id='tok-23-18' style='color:red'>(ISO/IEC</span><span class='token pointer' id='tok-23-19' style='color:red'>class A, B, or C</span>The activation sequence goes like this: </p><p id=p156><span class='token pointer' id='tok-23-20' style='color:red'>RST</span><span class='token pointer' id='tok-23-21' style='color:red'>pin</span>should be put to LOW state.Vcc pin should be <span class='token pointer' id='tok-23-22' style='color:red'>powered.I/O</span>pin on the smartcard terminal should be put to receive mode, even though it could ignore the <span class='token pointer' id='tok-23-23' style='color:red'>I/O</span><span class='token pointer' id='tok-23-24' style='color:red'>place.CLK</span><span class='token pointer' id='tok-23-25' style='color:red'>logic while smartcard activation takes</span>should provide clock <span class='token pointer' id='tok-23-26' style='color:red'>signal</span>to the <span class='token pointer' id='tok-23-27' style='color:red'>smartcard.More</span>detailed information about this smartcard activation (before timing <span class='token pointer' id='tok-23-28' style='color:red'>Ta)</span>can be seen in this picture: </p><p id=p215>2. Cold Reset </p><p id=p218>At the end of activation (RST pin pulled to LOW, Vcc pin has been powered, I/O on smartcard terminal has been put to receive mode and <span class='token pointer' id='tok-23-29' style='color:red'>CLK</span>pin supplied a stable clock signal), then the smartcard is ready to enter Cold Reset. </p><p id=p260>As you can see from the above picture, the clock signal at the CLK pin starts at Ta and the smartcard will set the <span class='token pointer' id='tok-23-30' style='color:red'>I/O signal</span>HIGH in 200 clock cycle (ta delay) after the clock signal is applied to CLK pin (Ta + ta). The RST pin should be kept in LOW state for at least 400 clock cycles (tb delay) after clock signal has been given to CLK pin <span class='token pointer' id='tok-23-31' style='color:red'>(Ta + tb).</span>smartcard terminal could ignore the logic in I/O pin when RST pin is on LOW state. </p><p id=p352>RST pin then change to HIGH state after reaching <span class='token pointer' id='tok-23-32' style='color:red'>Tb.</span>I/O pin will begin the <span class='token pointer' id='tok-23-33' style='color:red'>Answer-to-Reset</span>from 400 to 40000 clock cycle (tc delay) after rising edge signal in RST pin (Tb + tc). If there is no answer after the 40000 clock cycle when the RST pin is in HIGH state, then the smartcard terminal could deactivate the smartcard. </p><p id=p412>3. <span class='token pointer' id='tok-23-34' style='color:red'>ATR</span><span class='token pointer' id='tok-23-35' style='color:red'>Smartcard</span></p><p id=p416>After the smartcard performs a cold reset, then it will continue with Answer-to-Reset (ATR). The complete ATR structure is covered in <span class='token pointer' id='tok-23-36' style='color:red'>ISO/IEC 7816-3,</span>it looks like this: </p><p id=p444>TS T0 <span class='token pointer' id='tok-23-37' style='color:red'>TA1</span>TB1 TC1 TD1 TA2 … … TDn T1 … TK TCK </p><p id=p458>For example, this is the Answer-to-Reset that we receive after performing a cold reset on a smartcard: </p><p id=p475>3B BE 94 00 40 14 47 47 33 53 33 44 48 41 54 4C 39 31 30 30 </p><p id=p495>After receiving the ATR above, we then continue with interpreting the data as follows: </p><p id=p509>TS = <span class='token pointer' id='tok-23-38' style='color:red'>3BIt</span>means that the smartcard operates using direct convention that works almost like UART protocol. The direct <span class='token pointer' id='tok-23-39' style='color:red'>convention</span>operation was covered in ISO/IEC 7816-3. </p><p id=p535><span class='token pointer' id='tok-23-40' style='color:red'>High nibble (B16 = 10112)</span>that there is a data on TA1, TB1, dan TD1. </p><p id=p556>– <span class='token pointer' id='tok-23-41' style='color:red'>Low nibble (E16 = 1410)</span>that there is 14 bytes of history data (TK). </p><p id=p572>TA1 = 94 (1001 01002)– High <span class='token pointer' id='tok-23-42' style='color:red'>nibble</span>(916 = 10012) means that the clock rate is <span class='token pointer' id='tok-23-43' style='color:red'>Fi = 512</span>fmax = 5 MHz. </p><p id=p596>– Low nibble (416 = 01002) means that bit rate Di = 8. </p><p id=p609>TB1 = 00According to ISO/IEC 7816-3, the TB1 and TB2 has been deprecated and not used anymore so the smartcard doesn't have to transmit it and the smartcard terminal could just ignore it. </p><p id=p642>TD1 = 40 (0100 00002)– High nibble (416 = 01002) means that TC2 contains data. </p><p id=p657>– Low nibble (016 = 00002) means that the smartcard is using T = 0 protocol. </p><p id=p673>TC2 = 14 (2010)This is the Waiting Time Integer (WI) with a value of 20. From the ISO/IEC 7816-3, the value could be used to calculate Waiting Time (WT) with this formula: </p><p id=p705>History bytes = 47 47 33 53 33 44 48 41 54 4C 39 31 30 30This could be converted to <span class='token pointer' id='tok-23-44' style='color:red'>ASCII</span>: G G 3 S 3 D H A T L 9 1 0 0 </p><p id=p742>4. <span class='token pointer' id='tok-23-45' style='color:red'>Protocol</span>and <span class='token pointer' id='tok-23-46' style='color:red'>Parameter</span><span class='token pointer' id='tok-23-47' style='color:red'>Selection</span>Interface <span class='token pointer' id='tok-23-48' style='color:red'>(PPS)</span></p><p id=p749>After getting Answer-to-Reset (ATR), the smartcard interface then could send PPS instruction to choose which protocol and parameter it would use to make data transfer between the smartcard and the terminal easier. </p><p id=p781>5. Data <span class='token pointer' id='tok-23-49' style='color:red'>Transfer</span>Between Smartcard and Terminal </p><p id=p788>After the Protocol and Parameter Selection (PPS) has been setup, the smartcard and the terminal interface could begin transferring data using Application Protocol Data Unit <span class='token pointer' id='tok-23-50' style='color:red'>(APDU).</span>The complete structure for APDU is covered in ISO <span class='token pointer' id='tok-23-51' style='color:red'>7816-4.</span></p><p id=p824><span class='token pointer' id='tok-23-52' style='color:red'>Vulnerabilities</span></p><p id=p825>There are quite a lot of vulnerabilities related to the java card, and most of them have been documented across the Internet. This is some of the <span class='token pointer' id='tok-23-53' style='color:red'>smartcard's</span>attack vector: </p><p id=p855>1. Physical attack: </p><p id=p858>Reverse <span class='token pointer' id='tok-23-54' style='color:red'>engineering.Smartcard</span>cloning.2. Remote attack: </p><p id=p863>IMSI <span class='token pointer' id='tok-23-55' style='color:red'>catcher.Attacking</span>a Smartcard </p><p id=p867>1. Physical Attack </p><p id=p870>Physical attack could be carried out if the attacker has physical contact with victim's smartcard and gets access to important data on the smartcard. Once the attacker has access to that important data, he/she could perform a smartcard cloning or reprogramming of the smartcard. </p><p id=p914>1.1. Reverse Engineering </p><p id=p917>Reverse engineering smartcard at silicon level is not an easy task and requires some special tools such as Scanning <span class='token pointer' id='tok-23-56' style='color:red'>(SEM)</span><span class='token pointer' id='tok-23-57' style='color:red'>Electron Microscope</span>Focused Ion Beam <span class='token pointer' id='tok-23-58' style='color:red'>(FIB).</span></p><p id=p944>1.2. Smartcard <span class='token pointer' id='tok-23-59' style='color:red'>Cloning</span></p><p id=p947>For this purpose, an attacker could use a couple of devices like an oscilloscope and smartcard reader. This is an example of DIY smartcard reader (phoenix reader): </p><p id=p974>However, there's a catch for the phoenix reader like the one in the above picture – its lack of application for interfacing with smartcard. The reference schematic for phoenix reader used in the above picture was developed by Dejan Kaljevic and is freely available. </p><p id=p1018>Smartcard cloning is not just about programming the smartcard, but also retrieving important information about the victim's smartcard such as which vendor issued the card. The more <span class='token pointer' id='tok-23-60' style='color:red'>convenient</span>way to interact with the smartcard is by using <span class='token pointer' id='tok-23-61' style='color:red'>PCSC</span>reader with an opensource application called <span class='token pointer' id='tok-23-62' style='color:red'>pcsc_scan.</span> </p><p id=p1064>As you may see in the picture above, we could get some information from the smartcard <span class='token pointer' id='tok-23-63' style='color:red'>attached</span>to the terminal. Picture 10 shows a smartcard that's commonly used in a financial institution which complies with the <span class='token pointer' id='tok-23-64' style='color:red'>EMV standard,</span>picture 11 shows a smartcard <span class='token pointer' id='tok-23-65' style='color:red'>(USIM)</span>that's commonly used for communication (3G/4G). That information could be used to determine what kind of encryption the smartcard uses, since vendors tends to follow standard specs and not use custom encryption. Attackers could then use the information to perform a remote attack. </p><p id=p1152>2. Remote Attack </p><p id=p1155>Remote attacking smartcard could be achieved by exploiting vulnerabilities in the smartcard. For example; by injecting malicious </p><p id=p1174>2.1. </p><p id=p1177>The cost for this kind of attack is quite high, since the attacker must have some kind of hardware that could run <span class='token pointer' id='tok-23-66' style='color:red'>OpenBTS</span>and work as a fake <span class='token pointer' id='tok-23-67' style='color:red'>BTS.</span>In order to become a fake BTS, that hardware should generate a <span class='token pointer' id='tok-23-68' style='color:red'>stronger</span>signals than the real BTS to force the victim's terminal (i.e mobile phone) to connect to the fake BTS. </p><p id=p1238>After the victim's mobile phone is connected to the fake BTS, the attacker then could send a payload using the <span class='token pointer' id='tok-23-69' style='color:red'>Over-the-Air</span>(OTA) method that is common for <span class='token pointer' id='tok-23-70' style='color:red'>networks</span><span class='token pointer' id='tok-23-71' style='color:red'>GSM</span>direct the payload to the smartcard inside the mobile phone. </p><p id=p1278>Conclusion </p><p id=p1279>From the explanation above, we can conclude that an attacker who could exploit a vulnerability on smartcard would result in a catastrophic event, especially if it's related to a critical infrastructure, such as a SCADA installation that utilizes GSM networks or financial institution that utilize GSM networks for their mobile banking. In order to prevent such an attack on a smartcard, vendors could implement some protection, such as developing custom <span class='token pointer' id='tok-23-72' style='color:red'>EEPROM</span>for java card. </p><p id=p1353>      </p>