<p id=p0>This article covers how to <span class='token pointer' id='tok-77-0' style='color:red'>extract data</span>case of <span class='token pointer' id='tok-77-1' style='color:red'>SQL</span><span class='token pointer' id='tok-77-2' style='color:red'>injections in</span>and most efficient way. </p><p id=p19><span class='token pointer' id='tok-77-3' style='color:red'>vulnerability</span><span class='token pointer' id='tok-77-4' style='color:red'>OverviewSQL injection</span>been out there for a very long time and over a period of time, many researchers had presented tons of techniques for exploiting the vulnerability and <span class='token pointer' id='tok-77-5' style='color:red'>exfiltrating</span>data. However, there are certain techniques that are quite uncommon and very efficient in <span class='token pointer' id='tok-77-6' style='color:red'>exfiltration.</span><span class='token pointer' id='tok-77-7' style='color:red'>data</span>this article, we will have a look an in-depth look at some of these techniques and understand how we can implement them in real world scenarios and <span class='token pointer' id='tok-77-8' style='color:red'>exfiltrate data</span></p><p id=p97>The <span class='token pointer' id='tok-77-9' style='color:red'>test bed</span>for this article can be download from here. </p><p id=p109>We will be looking at following techniques: </p><p id=p116><span class='token pointer' id='tok-77-10' style='color:red'>Binary Conversion/Binary</span>of above techniques follow a trade off between length of <span class='token pointer' id='tok-77-11' style='color:red'>payload,</span><span class='token pointer' id='tok-77-12' style='color:red'>no</span>of <span class='token pointer' id='tok-77-13' style='color:red'>requests</span>sent and time taken to fetch the data. </p><p id=p141><span class='token pointer' id='tok-77-14' style='color:red'>Binary Conversion/Binary AndingIn</span>case, we convert <span class='token pointer' id='tok-77-15' style='color:red'>end character</span>its <span class='token pointer' id='tok-77-16' style='color:red'>binary</span>equivalent and <span class='token pointer' id='tok-77-17' style='color:red'>iterate</span>over binary <span class='token pointer' id='tok-77-18' style='color:red'>sequence</span>to get the original value back. To understand it easily, let us have a look at following sample payload. </p><p id=p178><span class='token pointer' id='tok-77-19' style='color:red'>Breakdown</span><span class='token pointer' id='tok-77-20' style='color:red'>Payload</span>break down the above payload we need to look at <span class='token pointer' id='tok-77-21' style='color:red'>innermost</span><span class='token pointer' id='tok-77-22' style='color:red'>query</span>as all of other <span class='token pointer' id='tok-77-23' style='color:red'>functions</span>are working on its results. </p><p id=p206>So the first <span class='token pointer' id='tok-77-24' style='color:red'>function</span><span class='token pointer' id='tok-77-25' style='color:red'>executes</span>as <span class='token pointer' id='tok-77-26' style='color:red'>select database();</span>we all know will return current <span class='token pointer' id='tok-77-27' style='color:red'>database</span>name as following. </p><p id=p225>The second function <span class='token pointer' id='tok-77-28' style='color:red'>"mid()"</span>selects first <span class='token pointer' id='tok-77-29' style='color:red'>character</span>from the output of database() function. </p><p id=p238>The third function generates an <span class='token pointer' id='tok-77-30' style='color:red'>ASCII</span>equivalent of character obtained from mid() function. </p><p id=p251>Finally, the fourth character creates a binary equivalent of character 's'. </p><p id=p262>As the <span class='token pointer' id='tok-77-31' style='color:red'>bin</span>function return the binary equivalent without <span class='token pointer' id='tok-77-32' style='color:red'>padding,</span>so we are using <span class='token pointer' id='tok-77-33' style='color:red'>lpad</span>function to <span class='token pointer' id='tok-77-34' style='color:red'>pad</span>zeros to the end result to balance the <span class='token pointer' id='tok-77-35' style='color:red'>loop</span>used in the final <span class='token pointer' id='tok-77-36' style='color:red'>script.</span></p><p id=p294>As we already know that <span class='token pointer' id='tok-77-37' style='color:red'>ASCII character</span>from 0 to 255, so the first character of the final binary sequence will always be zero. This leaves us with seven requests for each character, which obviously is a large no of requests but it takes less time in <span class='token pointer' id='tok-77-38' style='color:red'>fetching</span>larger data. </p><p id=p345>Let's run our <span class='token pointer' id='tok-77-39' style='color:red'>POC</span>script to determine how many requests it would take to determine the database name. </p><p id=p363>As can be seen, it took us seven requests per character to fetch out an eight character word. </p><p id=p381><span class='token pointer' id='tok-77-40' style='color:red'>Binary</span>to Position This <span class='token pointer' id='tok-77-41' style='color:red'>awesome</span>technique was presented by Roberto <span class='token pointer' id='tok-77-42' style='color:red'>Salgado</span>in <span class='token pointer' id='tok-77-43' style='color:red'>Blackhat USA 2013.</span>this case, the author uses a function named <span class='token pointer' id='tok-77-44' style='color:red'>find_in_set</span>which finds the location of the character in a character <span class='token pointer' id='tok-77-45' style='color:red'>set</span>by returning the <span class='token pointer' id='tok-77-46' style='color:red'>index</span>of the character. Further, the author converts the returned index into binary and retrieves the character. </p><p id=p437>ExampleLet us fetch the database name i.e. "security" again from our previous example. In order to that we need to fetch it one character at a time. We can use following function for that. </p><p id=p471><span class='token pointer' id='tok-77-47' style='color:red'>mid('security',1,1)</span>-> 's' </p><p id=p474>Lets us define one character set as follows </p><p id=p482></p><p id=p485>Now if we use <span class='token pointer' id='tok-77-48' style='color:red'>find_in_set(substr('sahil',1,1)),</span>it will return 19 as the character 's' is placed at 19th <span class='token pointer' id='tok-77-49' style='color:red'>position</span>in character set. </p><p id=p506>We will now be converting the obtained index into binary using the following function. </p><p id=p520><span class='token pointer' id='tok-77-50' style='color:red'>bin(find_in_set(mid('security',1,1)))</span>–> 1011 (4 requests) </p><p id=p525>As can be seen, we now have 4 <span class='token pointer' id='tok-77-51' style='color:red'>bytes</span>of binary to be retrieved, however there is some challenge in using this technique which is "determining the end of binary sequence" i.e. how the automated program will know that the binary sequence is ended, and it should stop retrieving the position data for any particular character. Well, in this case, the author is using <span class='token pointer' id='tok-77-52' style='color:red'>mySQL</span>variables to determine whether the <span class='token pointer' id='tok-77-53' style='color:red'>mid/substr</span><span class='token pointer' id='tok-77-54' style='color:red'>None</span><span class='token pointer' id='tok-77-55' style='color:red'>function returns</span>yes then <span class='token pointer' id='tok-77-56' style='color:red'>sleep</span>for some time and <span class='token pointer' id='tok-77-57' style='color:red'>break out of</span>loop. </p><p id=p612>Now, you might be thinking, will it take one additional request to fetch out binary sequence? </p><p id=p628>The answer is no because we already knew that all <span class='token pointer' id='tok-77-58' style='color:red'>characters</span>in our character set would already have one <span class='token pointer' id='tok-77-59' style='color:red'>byte.</span></p><p id=p648>Example: for character a, it should ideally take 2 requests, one for actual binary data and one for determining the end of binary sequence, but we already knew that a is present at first position i.e </p><p id=p684>For a : <span class='token pointer' id='tok-77-60' style='color:red'>1,b:10,c:11,d:100</span></p><p id=p688>So here we always need to fetch from the second character instead of first character. </p><p id=p703>Complete Payload: </p><p id=p705><span class='token pointer' id='tok-77-61' style='color:red'>database()),1,1)),'48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,58,59,60,61,62,63,64,91,92,93,94,95,96,123,124,125,126,32,9,10,13,11,12′)),2,1))=@a)</span><span class='token pointer' id='tok-77-62' style='color:red'>((SELECT @a:=MID(BIN(FIND_IN_SET(ascii(MID((select</span><span class='token pointer' id='tok-77-63' style='color:red'>(IF(@a!=",@a,sleep(1)))Payload BreakdownIn</span>to breakdown the above payload we will again tear it a part by innermost functions first. </p><p id=p728>The innermost function which is select database() will return database name. </p><p id=p739>The second function is a <span class='token pointer' id='tok-77-64' style='color:red'>substr</span>function, selecting the first character of the database name. </p><p id=p754>In the third function, we are obtaining ASCII equivalent of the first character of the database name. </p><p id=p771>Finally, in the fourth function, we are locating the position of 115 in defined set. </p><p id=p786>The fourth function returned that 115 is located at the 29th index of defined character set, let's convert this value into binary. </p><p id=p808>As can be seen in the above screenshot, we have 5 bytes to fetch out now, but as bin function does not pad the resultant binary sequence, and also we don't want to send extra requests for fetching this sequence. We will use the property of <span class='token pointer' id='tok-77-65' style='color:red'>substr/mid</span>function i.e. it does not return anything when requested index is greater than actual length. </p><p id=p870>Example As can be seen, the word 'sahil' is of 5 characters in length, however, if we ask the mid function to fetch out six characters, it will return None. </p><p id=p900>Well using the above technique we can determine the end of binary sequence i.e. when the mid function does not return anything sleep for 1-2 seconds, thus effectively breaking out of the loop and moving on to next character. </p><p id=p939><span class='token pointer' id='tok-77-66' style='color:red'>Ethical Hacking Training</span>Resources <span class='token pointer' id='tok-77-67' style='color:red'>(InfoSec)</span></p><p id=p945>As can be seen in the above screenshot, we are retrieving 6th character. However, we have seen in our previous query, the binary sequence for the location of letter 's' was of 5 characters in length but as we are retrieving the 6th character, our if the condition gets triggered and thus indicating binary sequence is ended. </p><p id=p1002>Let's run our POC script to determine how many requests it would take to determine the database name. </p><p id=p1020>As can be seen, it took us 39 requests to determine the database name as compared to binary conversion.
 </p>